%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\makeatletter
\def\fnum@figure{\figurename\thefigure{}}
\makeatother
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\makeatletter
\def\fnum@table{\tablename\thetable{}}
\makeatother
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{io\_anim\_mvnx Documentation}
\date{Aug 04, 2019}
\release{0.1.0}
\author{Andres FR}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{io\_anim\_mvnx package}
\label{\detokenize{io_anim_mvnx:io-anim-mvnx-package}}\label{\detokenize{io_anim_mvnx::doc}}

\section{Submodules}
\label{\detokenize{io_anim_mvnx:submodules}}

\section{io\_anim\_mvnx.mvnx module}
\label{\detokenize{io_anim_mvnx:module-io_anim_mvnx.mvnx}}\label{\detokenize{io_anim_mvnx:io-anim-mvnx-mvnx-module}}\index{io\_anim\_mvnx.mvnx (module)@\spxentry{io\_anim\_mvnx.mvnx}\spxextra{module}}
This module contains functionality concerning the adaption of the
XSENS MVN-XML format into our Python setup.
The adaption tries to be as MVN-version-agnostc as possible. Still,
it is possible to validate the file against a given schema.

The official explanation can be found in section 14.4 of the
\sphinxstyleemphasis{XSENS MVN User Manual}:
\begin{quote}

\sphinxurl{https://usermanual.wiki/Document/MVNUserManual.1147412416.pdf}
\end{quote}

A copy is stored in this package’s repository:
\begin{quote}

\sphinxurl{https://github.com/andres-fr/blender-mvnx-io}
\end{quote}

The following section introduces more informally the contents of the imported
MVN file and the way they can be accessed from Python:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} MVNX schemata can be found in this package or in
\PYGZsh{} https://www.xsens.com/mvn/mvnx/schema.xsd
mvn\PYGZus{}path = \PYGZdq{}XXX\PYGZdq{}
mmvn = Mvnx(mvn\PYGZus{}path)

\PYGZsh{} These elements contain some small metadata:
mmvn.mvnx.attrib
mmvn.mvnx.comment.attrib
mmvn.mvnx.securityCode.attrib[\PYGZdq{}code\PYGZdq{}]
mmvn.mvnx.subject.attrib

\PYGZsh{} subject.segments contain 3D pos\PYGZus{}b labels:
for ch in mmvn.mvnx.subject.segments.iterchildren():
    ch.attrib, [p.attrib for p in ch.points.iterchildren()]

\PYGZsh{} Segments can look as follows: {}`{}`[\PYGZsq{}Pelvis\PYGZsq{}, \PYGZsq{}L5\PYGZsq{}, \PYGZsq{}L3\PYGZsq{}, \PYGZsq{}T12\PYGZsq{}, \PYGZsq{}T8\PYGZsq{}, \PYGZsq{}Neck\PYGZsq{},
\PYGZsq{}Head\PYGZsq{}, \PYGZsq{}RightShoulder\PYGZsq{}, \PYGZsq{}RightUpperArm\PYGZsq{}, \PYGZsq{}RightForeArm\PYGZsq{}, \PYGZsq{}RightHand\PYGZsq{},
\PYGZsq{}LeftShoulder\PYGZsq{}, \PYGZsq{}LeftUpperArm\PYGZsq{}, \PYGZsq{}LeftForeArm\PYGZsq{}, \PYGZsq{}LeftHand\PYGZsq{}, \PYGZsq{}RightUpperLeg\PYGZsq{},
\PYGZsq{}RightLowerLeg\PYGZsq{}, \PYGZsq{}RightFoot\PYGZsq{}, \PYGZsq{}RightToe\PYGZsq{}, \PYGZsq{}LeftUpperLeg\PYGZsq{}, \PYGZsq{}LeftLowerLeg\PYGZsq{},
\PYGZsq{}LeftFoot\PYGZsq{}, \PYGZsq{}LeftToe\PYGZsq{}]{}`{}`

\PYGZsh{} sensors is basically a list of names
for s in mmvn.mvnx.subject.sensors.iterchildren():
    s.attrib

\PYGZsh{}  Joints is a list that connects segment points:
for j in mmvn.mvnx.subject.joints.iterchildren():
    j.attrib[\PYGZdq{}label\PYGZdq{}], j.getchildren()

\PYGZsh{} miscellaneous:
for j in mmvn.mvnx.subject.ergonomicJointAngles.iterchildren():
    j.attrib, j.getchildren()

for f in mmvn.mvnx.subject.footContactDefinition.iterchildren():
    f.attrib, f.getchildren()

\PYGZsh{} The bulk of the data is in the frames.
frames\PYGZus{}metadata, config\PYGZus{}frames, normal\PYGZus{}frames = mmvn.extract\PYGZus{}frame\PYGZus{}info()
\end{sphinxVerbatim}

When calling \sphinxcode{\sphinxupquote{extract\_frame\_info}}, we expect specific fields to have
specific datatypes. This is reflected In the globals:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{KNOWN\PYGZus{}STR\PYGZus{}FIELDS}\PYG{p}{,} \PYG{n}{KNOWN\PYGZus{}INT\PYGZus{}FIELDS}\PYG{p}{,} \PYG{n}{KNOWN\PYGZus{}FLOAT\PYGZus{}VEC\PYGZus{}FIELDS}
\end{sphinxVerbatim}

These are passed as default parameters to the Mvnx constructor, but can be
changed at will. The following exemplifies how the metadata could look like:

Metadata:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{segmentCount}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sensorCount}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jointCount}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{22}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

And this what fields would the non-normal frames have:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orientation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{position}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ms}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{type}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

As for the normal frames:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orientation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{position}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{velocity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{acceleration}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{angularVelocity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{angularAcceleration}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{footContacts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sensorFreeAcceleration}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sensorMagneticField}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sensorOrientation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jointAngle}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jointAngleXZY}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{jointAngleErgo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{centerOfMass}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
 \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ms}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{type}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

More information about the MVNX format can be found in section 14.4 of the
already mentioned document:
\begin{quote}

\sphinxurl{https://usermanual.wiki/Document/MVNUserManual.1147412416.pdf}
\end{quote}
\index{Mvnx (class in io\_anim\_mvnx.mvnx)@\spxentry{Mvnx}\spxextra{class in io\_anim\_mvnx.mvnx}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.mvnx.}}\sphinxbfcode{\sphinxupquote{Mvnx}}}{\emph{mvnx\_path}, \emph{mvnx\_schema\_path=None}, \emph{str\_fields=\{'tc'}, \emph{'type'\}}, \emph{int\_fields=\{'index'}, \emph{'jointCount'}, \emph{'ms'}, \emph{'segmentCount'}, \emph{'sensorCount'}, \emph{'time'\}}, \emph{float\_vec\_fields=\{'acceleration'}, \emph{'angularAcceleration'}, \emph{'angularVelocity'}, \emph{'centerOfMass'}, \emph{'jointAngle'}, \emph{'jointAngleErgo'}, \emph{'jointAngleXZY'}, \emph{'orientation'}, \emph{'position'}, \emph{'sensorFreeAcceleration'}, \emph{'sensorMagneticField'}, \emph{'sensorOrientation'}, \emph{'velocity'\}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

This class imports and adapts an XML file (expected to be in MVNX format)
to a Python-friendly representation. See this module’s docstring for usage
examples and more information.
\index{export() (io\_anim\_mvnx.mvnx.Mvnx method)@\spxentry{export()}\spxextra{io\_anim\_mvnx.mvnx.Mvnx method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx.export}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export}}}{\emph{filepath}, \emph{pretty\_print=True}, \emph{extra\_comment=''}}{}
Saves the current \sphinxcode{\sphinxupquote{mvnx}} attribute to the given file path as XML and
adds the \sphinxcode{\sphinxupquote{self.mvnx.attrib{[}"pythonComment"{]}}} attribute with
a timestamp.

\end{fulllineitems}

\index{extract\_frame\_info() (io\_anim\_mvnx.mvnx.Mvnx method)@\spxentry{extract\_frame\_info()}\spxextra{io\_anim\_mvnx.mvnx.Mvnx method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx.extract_frame_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extract\_frame\_info}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The tuple \sphinxcode{\sphinxupquote{(frames\_metadata, config\_frames, normal\_frames)}}

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_frames() (io\_anim\_mvnx.mvnx.Mvnx static method)@\spxentry{extract\_frames()}\spxextra{io\_anim\_mvnx.mvnx.Mvnx static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx.extract_frames}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{extract\_frames}}}{\emph{mvnx}, \emph{str\_fields}, \emph{int\_fields}, \emph{fvec\_fields}}{}
The bulk of the MVNX file is the \sphinxcode{\sphinxupquote{mvnx-\textgreater{}subject-\textgreater{}frames}} section.
This function parses it and returns its information in a
python-friendly format, mainly via the \sphinxcode{\sphinxupquote{process\_dict}} function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mvnx}} \textendash{} An XML tree, expected to be in MVNX format

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fields}} (\sphinxstyleliteralemphasis{\sphinxupquote{collection}}) \textendash{} Collection of strings with field names that
are converted to the specified type (fvec is a vector of floats).

\end{itemize}

\item[{Returns}] \leavevmode
a tuple \sphinxcode{\sphinxupquote{(frames\_metadata, config\_frames, normal\_frames)}}
where the metadata is a dict in the form \sphinxcode{\sphinxupquote{\{'segmentCount': 23,
'sensorCount': 17, 'jointCount': 22\}}}, the config frames are the
first 3 frame entries (expected to contain special config info)
and the normal\_frames are all frames starting from the 4th.
Fields found in the given int and vec field lists will be converted
and the rest will remain as XML nodes.

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_joints() (io\_anim\_mvnx.mvnx.Mvnx method)@\spxentry{extract\_joints()}\spxextra{io\_anim\_mvnx.mvnx.Mvnx method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx.extract_joints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extract\_joints}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A tuple (X, Y). The element X is a list of the joint names
ordered as they appear in the MVNX file.
The element Y is a list in the original MVNX ordering, in the form
{[}((seg\_ori, point\_ori), (seg\_dest, point\_dest)), …{]}, where each
element contains 4 strings summarizing the origin-\textgreater{}destiny of a
connection.

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_segments() (io\_anim\_mvnx.mvnx.Mvnx method)@\spxentry{extract\_segments()}\spxextra{io\_anim\_mvnx.mvnx.Mvnx method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx.extract_segments}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extract\_segments}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A list of the segment names in \sphinxcode{\sphinxupquote{self.mvnx.subject.segments}}
ordered by id (starting at 1 and incrementing +1).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{process\_dict() (in module io\_anim\_mvnx.mvnx)@\spxentry{process\_dict()}\spxextra{in module io\_anim\_mvnx.mvnx}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.process_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.mvnx.}}\sphinxbfcode{\sphinxupquote{process\_dict}}}{\emph{d}, \emph{str\_fields}, \emph{int\_fields}, \emph{fvec\_fields}}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
a copy of the given dict where the values (expected strings)
whose keys are in the specified fields are converted to the specified
type. E.g. If \sphinxcode{\sphinxupquote{int\_fields}} contains the \sphinxcode{\sphinxupquote{index}} string and the given
dict contains the \sphinxcode{\sphinxupquote{index}} key, the corresponding value will be
converted via \sphinxcode{\sphinxupquote{int()}}.

\end{description}\end{quote}

\end{fulllineitems}

\index{str\_to\_vec() (in module io\_anim\_mvnx.mvnx)@\spxentry{str\_to\_vec()}\spxextra{in module io\_anim\_mvnx.mvnx}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.str_to_vec}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.mvnx.}}\sphinxbfcode{\sphinxupquote{str\_to\_vec}}}{\emph{x}}{}
Converts a node with a text like ‘1.23, 2.34 …’ into a list
like {[}1.23, 2.34, …{]}

\end{fulllineitems}



\section{io\_anim\_mvnx.mvnx\_import module}
\label{\detokenize{io_anim_mvnx:module-io_anim_mvnx.mvnx_import}}\label{\detokenize{io_anim_mvnx:io-anim-mvnx-mvnx-import-module}}\index{io\_anim\_mvnx.mvnx\_import (module)@\spxentry{io\_anim\_mvnx.mvnx\_import}\spxextra{module}}
This module contains the required functionality to import an MVNX file as a
moving set of bones into Blender.

It allows for different options regarding their connectivity, scale…

The general workflow is documented in section 5 of the \sphinxstyleemphasis{Moven User Manual}:
\begin{quote}

\sphinxurl{http://www.cs.unc.edu/Research/stc/FAQs/Xsens/Moven/Moven\%20User\%20Manual.pdf}
\end{quote}

A copy is stored in this package’s repository:
\begin{quote}

\sphinxurl{https://github.com/andres-fr/blender-mvnx-io}
\end{quote}

See the specific docstrings and code commentary for more details.
\index{global\_to\_inherited\_quats() (in module io\_anim\_mvnx.mvnx\_import)@\spxentry{global\_to\_inherited\_quats()}\spxextra{in module io\_anim\_mvnx.mvnx\_import}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx_import.global_to_inherited_quats}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.mvnx\_import.}}\sphinxbfcode{\sphinxupquote{global\_to\_inherited\_quats}}}{\emph{quaternions}, \emph{joints}, \emph{name\_to\_idx\_map}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{quaternions}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} {[}q1, q2, …{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{joints}} \textendash{} A list of segment connections in the form
{[}(parent\_name, child\_name), …{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name\_to\_idx\_map}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} A dict in the form \{seg\_name: idx, …\} where
The quaternion for the segment seg\_name can be found in quaternions{[}idx{]}.

\end{itemize}

\end{description}\end{quote}

Given the list of MVNX quaternions and their tree relations,
return a list with same shape, but each quaternion is expressed relative
to its parent. For that, it suffices the following calculation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{q\PYGZus{}child\PYGZus{}relative} \PYG{o}{=} \PYG{n}{q\PYGZus{}parent\PYGZus{}glob}\PYG{o}{.}\PYG{n}{conjugated}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q\PYGZus{}child\PYGZus{}glob}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
This function assumes that all the input quaternion orientations are
given with respect to the same global reference.
\end{sphinxadmonition}

\end{fulllineitems}

\index{load\_mvnx\_into\_blender() (in module io\_anim\_mvnx.mvnx\_import)@\spxentry{load\_mvnx\_into\_blender()}\spxextra{in module io\_anim\_mvnx.mvnx\_import}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx_import.load_mvnx_into_blender}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.mvnx\_import.}}\sphinxbfcode{\sphinxupquote{load\_mvnx\_into\_blender}}}{\emph{context}, \emph{filepath}, \emph{mvnx\_schema\_path=None}, \emph{connectivity='CONNECTED'}, \emph{scale=1.0}, \emph{report=\textless{}built-in function print\textgreater{}}, \emph{frame\_start=0.0}, \emph{inherit\_rotations=True}, \emph{add\_identity\_pose=True}, \emph{add\_t\_pose=True}, \emph{verbose=True}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context}} \textendash{} A Blender context like bpy.context

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filepath}} \textendash{} Path expected to point to an MVNX file (XML)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mvnx\_schema\_path}} \textendash{} Optional path to a validation schema for the MVNX

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{connectivity}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} One of \sphinxcode{\sphinxupquote{{[}'CONNECTED', 'INDIVIDUAL'{]}}}. If
individual, all bones will have no parent and no children, and their
positions and rotations will be loaded independently from the others.
If connected, the relations defined in the MVNX will be regarded to form
a tree of bones, where only the tree roots will have a position. All
bones will in any case have angles: see \sphinxcode{\sphinxupquote{inherit\_rotations}} for more
information.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inherit\_rotations}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, rotating a bone will propagate
the same rotation to all its children, so the rotations are expressed
with respect to the parent. Otherwise the rotations are absolute and
rotating a bone will displace the children but their orientation won’t
change. Note that in both modes the imported animation will look
identical.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{add\_identity\_pose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, the ‘identity’ frame (zero
rotations) is added at the beginning of the sequence.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{add\_t\_pose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, the ‘tpose’ frame is added at the
beginning of the sequence (but after the identity if given).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If true, prints some information about the process
to the terminal.

\end{itemize}

\item[{Returns}] \leavevmode
A tuple \sphinxcode{\sphinxupquote{(arm\_ob, mvnx)}}, where mvnx is a pointer to the
Mvnx instance (basically an objectified XML file with extra
functionality), and arm\_ob is a pointer to the created Blender Armature
(whose name will be the same as the MVNX file, plus potentially extra
‘.XYZ’ digits if a file is imported multiple times).

\end{description}\end{quote}

The main routine in this module: given the MVNX information and some other
configurations, it creates a set of bones in Blender (so-called \sphinxstyleemphasis{Armature})
that will have the shape and perform the sequence specified in the MVNX.

\end{fulllineitems}

\index{set\_bone\_head\_and\_tail() (in module io\_anim\_mvnx.mvnx\_import)@\spxentry{set\_bone\_head\_and\_tail()}\spxextra{in module io\_anim\_mvnx.mvnx\_import}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx_import.set_bone_head_and_tail}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.mvnx\_import.}}\sphinxbfcode{\sphinxupquote{set\_bone\_head\_and\_tail}}}{\emph{bone, segment\_points, joints, root\_points={[}'pHipOrigin'{]}, leaf\_points={[}'pTopOfHead', 'pRightTopOfHand', 'pLeftTopOfHand', 'pRightToe', 'pLeftToe'{]}, scale=1.0}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bone}} \textendash{} an EditBone

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{segment\_points}} \textendash{} A dict of dicts that allows to find an offset given
a joint connector. Expected: \{seg\_name: \{p\_name: 3d\_vector, …\}, …\}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{joints}} \textendash{} A list in the original MVNX ordering, in the form
{[}((seg\_ori, point\_ori), (seg\_dest, point\_dest)), …{]}, where each element
contains 4 strings summarizing the origin-\textgreater{}destiny of a connection.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{root\_points}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} If a given bone/segment is root (has no parent),
the first match in this list will be taken as bone.head.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{leaf\_points}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} If a given bone/segment is a leaf (has no
children), the first match in this list will be taken as bone.tail.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} A positive float by which head and tail vectors will
be multiplied.

\end{itemize}

\end{description}\end{quote}

For a given bone, this function reads the information of its parent and,
given some MVNX data and assumptions, calculates its head and tail
positions. It is also responsible of rescaling the armature.

\begin{sphinxadmonition}{warning}{Warning:}\begin{description}
\item[{This function assumes the following:}] \leavevmode\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
If the bone has a parent, it can be found under bone.parent.

\item {} 
The head and tail of the parent have been already properly set.

\item {} 
If this bone is a root, its segment will have a point with
a label in root\_points.

\item {} 
If this bone is a leaf, its segment will have a point with
a label in leaf\_points.

\item {} 
For a given bone, there aren’t any possible collisions between the
different root or head\_points, i.e., the first match in the list
will always be a good match (this happens e.g. if each leaf has
a uniquely named leaf\_point, which is usually the case).

\end{enumerate}

\end{description}
\end{sphinxadmonition}

\end{fulllineitems}



\section{io\_anim\_mvnx.operators module}
\label{\detokenize{io_anim_mvnx:module-io_anim_mvnx.operators}}\label{\detokenize{io_anim_mvnx:io-anim-mvnx-operators-module}}\index{io\_anim\_mvnx.operators (module)@\spxentry{io\_anim\_mvnx.operators}\spxextra{module}}
This module contains subclasses from \sphinxcode{\sphinxupquote{bpy.types.Operator}} defining
user-callable functors. Operators can also be embedded in Panels and
other UI elements.
\index{ImportMVNX (class in io\_anim\_mvnx.operators)@\spxentry{ImportMVNX}\spxextra{class in io\_anim\_mvnx.operators}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.operators.}}\sphinxbfcode{\sphinxupquote{ImportMVNX}}}
Bases: \sphinxcode{\sphinxupquote{bpy\_types.Operator}}, \sphinxcode{\sphinxupquote{bpy\_extras.io\_utils.ImportHelper}}

Load an MVNX motion capture file. This Operator is heavily inspired in the
oficially supported ImportBVH.
\index{VERBOSE\_IMPORT (io\_anim\_mvnx.operators.ImportMVNX attribute)@\spxentry{VERBOSE\_IMPORT}\spxextra{io\_anim\_mvnx.operators.ImportMVNX attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.VERBOSE_IMPORT}}\pysigline{\sphinxbfcode{\sphinxupquote{VERBOSE\_IMPORT}}\sphinxbfcode{\sphinxupquote{ = True}}}
\end{fulllineitems}

\index{bl\_idname (io\_anim\_mvnx.operators.ImportMVNX attribute)@\spxentry{bl\_idname}\spxextra{io\_anim\_mvnx.operators.ImportMVNX attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.bl_idname}}\pysigline{\sphinxbfcode{\sphinxupquote{bl\_idname}}\sphinxbfcode{\sphinxupquote{ = 'import\_anim.mvnx'}}}
\end{fulllineitems}

\index{bl\_label (io\_anim\_mvnx.operators.ImportMVNX attribute)@\spxentry{bl\_label}\spxextra{io\_anim\_mvnx.operators.ImportMVNX attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.bl_label}}\pysigline{\sphinxbfcode{\sphinxupquote{bl\_label}}\sphinxbfcode{\sphinxupquote{ = 'Import MVNX'}}}
\end{fulllineitems}

\index{bl\_options (io\_anim\_mvnx.operators.ImportMVNX attribute)@\spxentry{bl\_options}\spxextra{io\_anim\_mvnx.operators.ImportMVNX attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.bl_options}}\pysigline{\sphinxbfcode{\sphinxupquote{bl\_options}}\sphinxbfcode{\sphinxupquote{ = \{'REGISTER', 'UNDO'\}}}}
\end{fulllineitems}

\index{bl\_rna (io\_anim\_mvnx.operators.ImportMVNX attribute)@\spxentry{bl\_rna}\spxextra{io\_anim\_mvnx.operators.ImportMVNX attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.bl_rna}}\pysigline{\sphinxbfcode{\sphinxupquote{bl\_rna}}\sphinxbfcode{\sphinxupquote{ = \textless{}bpy\_struct, Struct("IMPORT\_ANIM\_OT\_mvnx")\textgreater{}}}}
\end{fulllineitems}

\index{execute() (io\_anim\_mvnx.operators.ImportMVNX method)@\spxentry{execute()}\spxextra{io\_anim\_mvnx.operators.ImportMVNX method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.execute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{execute}}}{\emph{context}}{}
Passes the properties captured by the UI to the load\_mvnx\_into\_blender
function.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxcode{\sphinxupquote{\{'FINISHED'\}}} if everything went OK, \sphinxcode{\sphinxupquote{\{'CANCELLED'\}}}
otherwise.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{io\_anim\_mvnx.utils module}
\label{\detokenize{io_anim_mvnx:module-io_anim_mvnx.utils}}\label{\detokenize{io_anim_mvnx:io-anim-mvnx-utils-module}}\index{io\_anim\_mvnx.utils (module)@\spxentry{io\_anim\_mvnx.utils}\spxextra{module}}
Utilities for interaction with Blender
\index{ArgumentParserForBlender (class in io\_anim\_mvnx.utils)@\spxentry{ArgumentParserForBlender}\spxextra{class in io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.ArgumentParserForBlender}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{ArgumentParserForBlender}}}{\emph{prog=None}, \emph{usage=None}, \emph{description=None}, \emph{epilog=None}, \emph{parents={[}{]}}, \emph{formatter\_class=\textless{}class 'argparse.HelpFormatter'\textgreater{}}, \emph{prefix\_chars='-'}, \emph{fromfile\_prefix\_chars=None}, \emph{argument\_default=None}, \emph{conflict\_handler='error'}, \emph{add\_help=True}, \emph{allow\_abbrev=True}}{}
Bases: \sphinxcode{\sphinxupquote{argparse.ArgumentParser}}

This class is identical to its superclass, except for the parse\_args
method (see docstring). It resolves the ambiguity generated when calling
Blender from the CLI with a python script, and both Blender and the script
have arguments. E.g., the following call will make Blender crash because
it will try to process the script’s -a and -b flags:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{blender} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{python} \PYG{n}{my\PYGZus{}script}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

To bypass this issue this class uses the fact that Blender will ignore all
arguments given after a double-dash (‘\textendash{}’). The approach is that all
arguments before ‘\textendash{}’ go to Blender, arguments after go to the script.
The following CLI calls work fine:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{blender} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{python} \PYG{n}{my\PYGZus{}script}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mi}{2}
\PYG{n}{blender} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{python} \PYG{n}{my\PYGZus{}script}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\end{sphinxVerbatim}
\index{get\_argv\_after\_doubledash() (io\_anim\_mvnx.utils.ArgumentParserForBlender method)@\spxentry{get\_argv\_after\_doubledash()}\spxextra{io\_anim\_mvnx.utils.ArgumentParserForBlender method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.ArgumentParserForBlender.get_argv_after_doubledash}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_argv\_after\_doubledash}}}{\emph{argv}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{argv}} (\sphinxstyleliteralemphasis{\sphinxupquote{list\textless{}str\textgreater{}}}) \textendash{} Expected to be sys.argv (or alike).

\item[{Returns}] \leavevmode
The argv sublist after the first \sphinxcode{\sphinxupquote{'-{-}'}} element (if
present, otherwise returns an empty list).

\item[{Return type}] \leavevmode
list of str

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Works with any \sphinxstyleemphasis{ordered} collection of strings (e.g. list, tuple).
\end{sphinxadmonition}

\end{fulllineitems}

\index{parse\_args() (io\_anim\_mvnx.utils.ArgumentParserForBlender method)@\spxentry{parse\_args()}\spxextra{io\_anim\_mvnx.utils.ArgumentParserForBlender method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.ArgumentParserForBlender.parse_args}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parse\_args}}}{}{}
This method is expected to behave identically as in the superclass,
except that the sys.argv list will be pre-processed using
get\_argv\_after\_doubledash before. See the docstring of the class for
usage examples and details.

\begin{sphinxadmonition}{note}{Note:}
By default, \sphinxtitleref{argparse.ArgumentParser} will call \sphinxtitleref{sys.exit()} when
encountering an error. Blender will react to that shutting down,
making it look like a crash. Make sure the arguments are correct!
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}

\index{ImportFilesCollection (class in io\_anim\_mvnx.utils)@\spxentry{ImportFilesCollection}\spxextra{class in io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.ImportFilesCollection}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{ImportFilesCollection}}}
Bases: \sphinxcode{\sphinxupquote{bpy\_types.PropertyGroup}}

This property group allows to load multiple files from the UI file browser
menu, by selecting them with shift pressed.
Source and usage example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
https://www.blender.org/forum/viewtopic.php?t=26470
\end{sphinxVerbatim}
\index{bl\_rna (io\_anim\_mvnx.utils.ImportFilesCollection attribute)@\spxentry{bl\_rna}\spxextra{io\_anim\_mvnx.utils.ImportFilesCollection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.ImportFilesCollection.bl_rna}}\pysigline{\sphinxbfcode{\sphinxupquote{bl\_rna}}\sphinxbfcode{\sphinxupquote{ = \textless{}bpy\_struct, Struct("ImportFilesCollection")\textgreater{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{KeymapManager (class in io\_anim\_mvnx.utils)@\spxentry{KeymapManager}\spxextra{class in io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{KeymapManager}}}
Bases: \sphinxcode{\sphinxupquote{list}}

This class implements functionality for registering/deregistering keymaps
into Blender. It also behaves like a regular list, holding the keymaps
currently registered. To inspect the registered keymaps simply iterate
the instance.
\index{KEYMAP\_NAME (io\_anim\_mvnx.utils.KeymapManager attribute)@\spxentry{KEYMAP\_NAME}\spxextra{io\_anim\_mvnx.utils.KeymapManager attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager.KEYMAP_NAME}}\pysigline{\sphinxbfcode{\sphinxupquote{KEYMAP\_NAME}}\sphinxbfcode{\sphinxupquote{ = 'Object Mode'}}}
\end{fulllineitems}

\index{KEYMAP\_REGION\_TYPE (io\_anim\_mvnx.utils.KeymapManager attribute)@\spxentry{KEYMAP\_REGION\_TYPE}\spxextra{io\_anim\_mvnx.utils.KeymapManager attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager.KEYMAP_REGION_TYPE}}\pysigline{\sphinxbfcode{\sphinxupquote{KEYMAP\_REGION\_TYPE}}\sphinxbfcode{\sphinxupquote{ = 'WINDOW'}}}
\end{fulllineitems}

\index{KEYMAP\_SPACE\_TYPE (io\_anim\_mvnx.utils.KeymapManager attribute)@\spxentry{KEYMAP\_SPACE\_TYPE}\spxextra{io\_anim\_mvnx.utils.KeymapManager attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager.KEYMAP_SPACE_TYPE}}\pysigline{\sphinxbfcode{\sphinxupquote{KEYMAP\_SPACE\_TYPE}}\sphinxbfcode{\sphinxupquote{ = 'EMPTY'}}}
\end{fulllineitems}

\index{register() (io\_anim\_mvnx.utils.KeymapManager method)@\spxentry{register()}\spxextra{io\_anim\_mvnx.utils.KeymapManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager.register}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{register}}}{\emph{context}, \emph{key}, \emph{stroke\_mode}, \emph{op\_name}, \emph{ctrl=True}, \emph{shift=True}, \emph{alt=False}}{}
Adds a new keymap to this collection, and to the config in
\sphinxcode{\sphinxupquote{context.window\_manager.keyconfigs.addon}}. See the API for details:

\begin{DUlineblock}{0em}
\item[] \sphinxurl{https://docs.blender.org/api/blender2.8/bpy.types.KeyMap.html}
\item[] \sphinxurl{https://docs.blender.org/api/blender2.8/bpy.types.KeyMapItem.html}
\item[] \sphinxurl{https://docs.blender.org/manual/de/dev/advanced/keymap\_editing.html}
\end{DUlineblock}

Usage example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{kmm} \PYG{o}{=} \PYG{n}{KeymapManager}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{kmm}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{n}{bpy}\PYG{o}{.}\PYG{n}{context}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{D}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PRESS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{MyOperator}\PYG{o}{.}\PYG{n}{bl\PYGZus{}idname}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context}} (\sphinxstyleliteralemphasis{\sphinxupquote{bpy.types.Context}}) \textendash{} The Blender context to work in.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{key}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} See bpy.types.KeyMapItem.key\_modifier

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stroke\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} See bpy.types.KeyMapItem.value

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{op\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of a valid operation in \sphinxcode{\sphinxupquote{bpy.ops}}
(usually the \sphinxcode{\sphinxupquote{bl\_idname}})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ctrl}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{shift}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{alt}} (\sphinxstyleliteralemphasis{\sphinxupquote{booleans}}) \textendash{} Modifiers of the \sphinxcode{\sphinxupquote{key}}

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{unregister() (io\_anim\_mvnx.utils.KeymapManager method)@\spxentry{unregister()}\spxextra{io\_anim\_mvnx.utils.KeymapManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager.unregister}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{unregister}}}{}{}
Removes every mapped item from every keymap in this collection, and
then empties the collection.

\end{fulllineitems}


\end{fulllineitems}

\index{OperatorToMenuManager (class in io\_anim\_mvnx.utils)@\spxentry{OperatorToMenuManager}\spxextra{class in io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.OperatorToMenuManager}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{OperatorToMenuManager}}}
Bases: \sphinxcode{\sphinxupquote{list}}

This class implements functionality for adding/removing operators
into Blender UI menus. It also behaves like a regular list, holding
the currently registered items. Usage example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{omm} \PYG{o}{=} \PYG{n}{OperatorToMenuManager}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} In register():}
\PYG{n}{omm}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{n}{MyOperator}\PYG{p}{,} \PYG{n}{bpy}\PYG{o}{.}\PYG{n}{types}\PYG{o}{.}\PYG{n}{VIEW3D\PYGZus{}MT\PYGZus{}object}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} ... in unregister():}
\PYG{n}{omm}\PYG{o}{.}\PYG{n}{unregister}
\end{sphinxVerbatim}
\index{register() (io\_anim\_mvnx.utils.OperatorToMenuManager method)@\spxentry{register()}\spxextra{io\_anim\_mvnx.utils.OperatorToMenuManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.OperatorToMenuManager.register}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{register}}}{\emph{op\_class}, \emph{menu\_class}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{op\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{bpy.types.Operator}}) \textendash{} (Sub)class handle with desired
functionality.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{menu\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{bpy.types.\{Header}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Panel}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{..\}}}) \textendash{} Class handle for the Blender GUI where the
functionality can be triggered.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{op\_class}} must define the \sphinxcode{\sphinxupquote{bl\_idname}} and \sphinxcode{\sphinxupquote{bl\_label}} fields.
\end{sphinxadmonition}

\end{fulllineitems}

\index{unregister() (io\_anim\_mvnx.utils.OperatorToMenuManager method)@\spxentry{unregister()}\spxextra{io\_anim\_mvnx.utils.OperatorToMenuManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.OperatorToMenuManager.unregister}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{unregister}}}{}{}
Removes every mapped operator from every menu class in this collection,
then empties the collection.

\end{fulllineitems}


\end{fulllineitems}

\index{is\_number() (in module io\_anim\_mvnx.utils)@\spxentry{is\_number()}\spxextra{in module io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.is_number}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{is\_number}}}{\emph{s}}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True iff s is a number.

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_timestamp() (in module io\_anim\_mvnx.utils)@\spxentry{make\_timestamp()}\spxextra{in module io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.make_timestamp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{make\_timestamp}}}{\emph{timezone='Europe/Berlin'}}{}
Output example: day, month, year, hour, min, sec, milisecs:
10\_Feb\_2018\_20:10:16.151

\end{fulllineitems}

\index{resolve\_path() (in module io\_anim\_mvnx.utils)@\spxentry{resolve\_path()}\spxextra{in module io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.resolve_path}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{resolve\_path}}}{\emph{*path\_elements}}{}
A convenience path wrapper to find elements in this package. Retrieves
the absolute path, given the OS-agnostic path relative to the package
root path (by bysically joining the path elements via \sphinxcode{\sphinxupquote{os.path.join}}).
E.g., the following call retrieves the absolute path for
\sphinxcode{\sphinxupquote{\textless{}PACKAGE\_ROOT\textgreater{}/a/b/test.txt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{resolve\PYGZus{}path}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Params strings path\_elements}] \leavevmode
From left to right, the path nodes,
the last one being the filename.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{rot\_euler\_degrees() (in module io\_anim\_mvnx.utils)@\spxentry{rot\_euler\_degrees()}\spxextra{in module io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.rot_euler_degrees}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{rot\_euler\_degrees}}}{\emph{rot\_x}, \emph{rot\_y}, \emph{rot\_z}, \emph{order='XYZ'}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{rot}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Rotation angle in degrees.

\item[{Returns}] \leavevmode
An Euler rotation object with the given rotations (converted to
gradians) and rotation order.

\end{description}\end{quote}

\end{fulllineitems}

\index{str\_to\_vec() (in module io\_anim\_mvnx.utils)@\spxentry{str\_to\_vec()}\spxextra{in module io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.str_to_vec}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{str\_to\_vec}}}{\emph{s}}{}
Converts a string like ‘1.23, 2.34 …’ into a list
like {[}1.23, 2.34, …{]}

\end{fulllineitems}



\section{Module contents}
\label{\detokenize{io_anim_mvnx:module-io_anim_mvnx}}\label{\detokenize{io_anim_mvnx:module-contents}}\index{io\_anim\_mvnx (module)@\spxentry{io\_anim\_mvnx}\spxextra{module}}
This add-on allows you to import motion capture data in MVNX format
into Blender.

After activating it, it features an operator that can be found in
\sphinxcode{\sphinxupquote{{[}File \textgreater{} Import/Export{]}}}. Clicking on it will open a file navigator
with a set of options to customize how the MVNX will be imported
into a Blender armature.

Position the mouse over the different options or read the corresponding
docstrings to get more info about what do they do.

To install this add-on, make sure Blender’s Python is able to find it
under \sphinxcode{\sphinxupquote{addon\_utils.paths()}}, and that the Blender version matches to make
it installable. Alternatively, run this init file as a script from Blender.
\index{register() (in module io\_anim\_mvnx)@\spxentry{register()}\spxextra{in module io\_anim\_mvnx}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.register}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.}}\sphinxbfcode{\sphinxupquote{register}}}{}{}
Main register function, called on startup by Blender

\end{fulllineitems}

\index{unregister() (in module io\_anim\_mvnx)@\spxentry{unregister()}\spxextra{in module io\_anim\_mvnx}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.unregister}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.}}\sphinxbfcode{\sphinxupquote{unregister}}}{}{}
Main unregister function, called on shutdown by Blender

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{i}
\item\relax\sphinxstyleindexentry{io\_anim\_mvnx}\sphinxstyleindexpageref{io_anim_mvnx:\detokenize{module-io_anim_mvnx}}
\item\relax\sphinxstyleindexentry{io\_anim\_mvnx.mvnx}\sphinxstyleindexpageref{io_anim_mvnx:\detokenize{module-io_anim_mvnx.mvnx}}
\item\relax\sphinxstyleindexentry{io\_anim\_mvnx.mvnx\_import}\sphinxstyleindexpageref{io_anim_mvnx:\detokenize{module-io_anim_mvnx.mvnx_import}}
\item\relax\sphinxstyleindexentry{io\_anim\_mvnx.operators}\sphinxstyleindexpageref{io_anim_mvnx:\detokenize{module-io_anim_mvnx.operators}}
\item\relax\sphinxstyleindexentry{io\_anim\_mvnx.utils}\sphinxstyleindexpageref{io_anim_mvnx:\detokenize{module-io_anim_mvnx.utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}