%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{io\_anim\_mvnx}
\date{Aug 02, 2019}
\release{0.1.0}
\author{Andres FR}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{io\_anim\_mvnx package}
\label{\detokenize{io_anim_mvnx:io-anim-mvnx-package}}\label{\detokenize{io_anim_mvnx::doc}}

\section{Submodules}
\label{\detokenize{io_anim_mvnx:submodules}}

\section{io\_anim\_mvnx.mvnx module}
\label{\detokenize{io_anim_mvnx:module-io_anim_mvnx.mvnx}}\label{\detokenize{io_anim_mvnx:io-anim-mvnx-mvnx-module}}\index{io\_anim\_mvnx.mvnx (module)@\spxentry{io\_anim\_mvnx.mvnx}\spxextra{module}}
This module contains functionality concerning the adaption of the
XSENS MVN-XML format into our Python setup.
\begin{description}
\item[{The official explanation can be found in section 14.4 of this document::}] \leavevmode
\sphinxurl{https://usermanual.wiki/Document/MVNUserManual.1147412416.pdf}

\end{description}

A copy is stored in this repository.

The following section introduces more informally the contents of the imported
MVN file and the way they can be accessed from Python:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{} MVNX schemata can be found in this package or in
\PYGZsh{} https://www.xsens.com/mvn/mvnx/schema.xsd
mvn\PYGZus{}path = \PYGZdq{}XXX\PYGZdq{}
mmvn = Mvnx(mvn\PYGZus{}path)

\PYGZsh{} These elements contain some small metadata:
mmvn.mvnx.attrib
mmvn.mvnx.comment.attrib
mmvn.mvnx.securityCode.attrib[\PYGZdq{}code\PYGZdq{}]
mmvn.mvnx.subject.attrib

\PYGZsh{} subject.segments contain 3D pos\PYGZus{}b labels:
for ch in mmvn.mvnx.subject.segments.iterchildren():
    ch.attrib, [p.attrib for p in ch.points.iterchildren()]

\PYGZsh{} Segments can look as follows: {}`{}`[\PYGZsq{}Pelvis\PYGZsq{}, \PYGZsq{}L5\PYGZsq{}, \PYGZsq{}L3\PYGZsq{}, \PYGZsq{}T12\PYGZsq{}, \PYGZsq{}T8\PYGZsq{}, \PYGZsq{}Neck\PYGZsq{},
\PYGZsq{}Head\PYGZsq{}, \PYGZsq{}RightShoulder\PYGZsq{}, \PYGZsq{}RightUpperArm\PYGZsq{}, \PYGZsq{}RightForeArm\PYGZsq{}, \PYGZsq{}RightHand\PYGZsq{},
\PYGZsq{}LeftShoulder\PYGZsq{}, \PYGZsq{}LeftUpperArm\PYGZsq{}, \PYGZsq{}LeftForeArm\PYGZsq{}, \PYGZsq{}LeftHand\PYGZsq{}, \PYGZsq{}RightUpperLeg\PYGZsq{},
\PYGZsq{}RightLowerLeg\PYGZsq{}, \PYGZsq{}RightFoot\PYGZsq{}, \PYGZsq{}RightToe\PYGZsq{}, \PYGZsq{}LeftUpperLeg\PYGZsq{}, \PYGZsq{}LeftLowerLeg\PYGZsq{},
\PYGZsq{}LeftFoot\PYGZsq{}, \PYGZsq{}LeftToe\PYGZsq{}]{}`{}`

\PYGZsh{} sensors is basically a list of names
for s in mmvn.mvnx.subject.sensors.iterchildren():
    s.attrib

\PYGZsh{}  Joints is a list that connects segment points:
for j in mmvn.mvnx.subject.joints.iterchildren():
    j.attrib[\PYGZdq{}label\PYGZdq{}], j.getchildren()

\PYGZsh{} miscellaneous:
for j in mmvn.mvnx.subject.ergonomicJointAngles.iterchildren():
    j.attrib, j.getchildren()

for f in mmvn.mvnx.subject.footContactDefinition.iterchildren():
    f.attrib, f.getchildren()

\PYGZsh{} The bulk of the data is in the frames.
frames\PYGZus{}metadata, config\PYGZus{}frames, normal\PYGZus{}frames = mmvn.extract\PYGZus{}frame\PYGZus{}info()

\PYGZsh{} Metadata looks like this:
\PYGZob{}\PYGZsq{}segmentCount\PYGZsq{}: \PYGZsq{}23\PYGZsq{}, \PYGZsq{}sensorCount\PYGZsq{}: \PYGZsq{}17\PYGZsq{}, \PYGZsq{}jointCount\PYGZsq{}: \PYGZsq{}22\PYGZsq{}\PYGZcb{}

\PYGZsh{} config frames have the following fields:
[\PYGZsq{}orientation\PYGZsq{}, \PYGZsq{}position\PYGZsq{}, \PYGZsq{}time\PYGZsq{}, \PYGZsq{}tc\PYGZsq{}, \PYGZsq{}ms\PYGZsq{}, \PYGZsq{}type\PYGZsq{}]

\PYGZsh{} normal frames have the following fields:
[\PYGZsq{}orientation\PYGZsq{}, \PYGZsq{}position\PYGZsq{}, \PYGZsq{}velocity\PYGZsq{}, \PYGZsq{}acceleration\PYGZsq{},
 \PYGZsq{}angularVelocity\PYGZsq{}, \PYGZsq{}angularAcceleration\PYGZsq{}, \PYGZsq{}footContacts\PYGZsq{},
 \PYGZsq{}sensorFreeAcceleration\PYGZsq{}, \PYGZsq{}sensorMagneticField\PYGZsq{}, \PYGZsq{}sensorOrientation\PYGZsq{},
 \PYGZsq{}jointAngle\PYGZsq{}, \PYGZsq{}jointAngleXZY\PYGZsq{}, \PYGZsq{}jointAngleErgo\PYGZsq{}, \PYGZsq{}centerOfMass\PYGZsq{}, \PYGZsq{}time\PYGZsq{},
 \PYGZsq{}index\PYGZsq{}, \PYGZsq{}tc\PYGZsq{}, \PYGZsq{}ms\PYGZsq{}, \PYGZsq{}type\PYGZsq{}]
\end{sphinxVerbatim}

The following fields contain metadata about the frame:
\begin{quote}\begin{description}
\item[{time}] \leavevmode
ms since start (integer). It is close to
\sphinxcode{\sphinxupquote{int(1000.0 * index / samplerate)}}, being equal most of the times and
at most 1 milisecond away. It is neither truncated nor rounded, maybe it
is given by the hardware.

\item[{index}] \leavevmode
starts with 0, +1 each normal frame

\item[{tc}] \leavevmode
string like ‘02:23:28:164’

\item[{ms}] \leavevmode
unix timestamp like 1515983008686 (used to compute time)

\item[{type}] \leavevmode
one of “identity”, “tpose”, “tpose-isb”, “normal”

\end{description}\end{quote}

\# The following fields are float vectors of the following dimensionality:
\begin{quote}\begin{description}
\item[{orientation}] \leavevmode
\sphinxcode{\sphinxupquote{segmentCount*4 = 92}} Quaternion vector

\item[{position, velocity, acceleration, angularVelocity, angularAcceleration}] \leavevmode
\sphinxcode{\sphinxupquote{segmentCount*3 = 69}} 3D vectors in \sphinxcode{\sphinxupquote{(x,y,z)}} format

\item[{footContacts}] \leavevmode
\sphinxcode{\sphinxupquote{4}} 4D boolean vector

\item[{sensorFreeAcceleration, sensorMagneticField}] \leavevmode
\sphinxcode{\sphinxupquote{sensorCount*3 = 51}}

\item[{sensorOrientation}] \leavevmode
\sphinxcode{\sphinxupquote{sensorCount*4 = 68}}

\item[{jointAngle, jointAngleXZY}] \leavevmode
\sphinxcode{\sphinxupquote{jointCount*3 = 66}}

\item[{jointAngleErgo}] \leavevmode
\sphinxcode{\sphinxupquote{12}}

\item[{centerOfMass}] \leavevmode
\sphinxcode{\sphinxupquote{3}}

\end{description}\end{quote}

The units are SI for position, velocity and acceleration. Angular magnitudes
are in radians except the \sphinxcode{\sphinxupquote{jointAngle...}} ones that are in degrees. All 3D
vectors are in \sphinxcode{\sphinxupquote{(x,y,z)}} format, but the \sphinxcode{\sphinxupquote{jointAngle...}} ones differ in
the Euler-rotation order by which they are computed (ZXY, standard or XZY,
for shoulders usually).
\index{Mvnx (class in io\_anim\_mvnx.mvnx)@\spxentry{Mvnx}\spxextra{class in io\_anim\_mvnx.mvnx}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.mvnx.}}\sphinxbfcode{\sphinxupquote{Mvnx}}}{\emph{mvnx\_path}, \emph{mvnx\_schema\_path=None}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

This class imports and adapts an XML file (expected to be in MVNX format)
to a Python-friendly representation. See this module’s docstring for usage
examples and more information.
\index{export() (io\_anim\_mvnx.mvnx.Mvnx method)@\spxentry{export()}\spxextra{io\_anim\_mvnx.mvnx.Mvnx method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx.export}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export}}}{\emph{filepath}, \emph{pretty\_print=True}, \emph{extra\_comment=''}}{}
Saves the current \sphinxcode{\sphinxupquote{mvnx}} attribute to the given file path as XML and
adds the \sphinxcode{\sphinxupquote{self.mvnx.attrib{[}"pythonComment"{]}}} attribute with
a timestamp.

\end{fulllineitems}

\index{extract\_frame\_info() (io\_anim\_mvnx.mvnx.Mvnx method)@\spxentry{extract\_frame\_info()}\spxextra{io\_anim\_mvnx.mvnx.Mvnx method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx.extract_frame_info}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extract\_frame\_info}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
The tuple \sphinxcode{\sphinxupquote{(frames\_metadata, config\_frames, normal\_frames)}}

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_frames() (io\_anim\_mvnx.mvnx.Mvnx static method)@\spxentry{extract\_frames()}\spxextra{io\_anim\_mvnx.mvnx.Mvnx static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx.extract_frames}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{extract\_frames}}}{\emph{mvnx}}{}
The bulk of the MVNX file is the \sphinxcode{\sphinxupquote{mvnx-\textgreater{}subject-\textgreater{}frames}} section.
This function parses it and returns its information in a
python-friendly format.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{mvnx}} \textendash{} An XML tree, expected to be in MVNX format

\item[{Returns}] \leavevmode
a tuple \sphinxcode{\sphinxupquote{(frames\_metadata, config\_frames, normal\_frames)}}
where the metadata is a dict in the form \sphinxcode{\sphinxupquote{\{'segmentCount': '23',
'sensorCount': '17', 'jointCount': '22'\}}}, the config frames are the
first 3 frame entries (expected to contain special config info)
and the normal\_frames are all frames starting from the 4th. Both
frame outputs are relational collections of dictionaries that can be
formatted into tabular form.

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_joints() (io\_anim\_mvnx.mvnx.Mvnx method)@\spxentry{extract\_joints()}\spxextra{io\_anim\_mvnx.mvnx.Mvnx method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx.extract_joints}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extract\_joints}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A tuple (X, Y). The element X is a list of the joint names
ordered as they appear in the MVNX file.
The element Y is a list in the original MVNX ordering, in the form
{[}((seg\_ori, point\_ori), (seg\_dest, point\_dest)), …{]}, where each
element contains 4 strings summarizing the origin-\textgreater{}destiny of a
connection.

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_segments() (io\_anim\_mvnx.mvnx.Mvnx method)@\spxentry{extract\_segments()}\spxextra{io\_anim\_mvnx.mvnx.Mvnx method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx.Mvnx.extract_segments}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extract\_segments}}}{}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A list of the segment names in \sphinxcode{\sphinxupquote{self.mvnx.subject.segments}}
ordered by id (starting at 1 and incrementing +1).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{io\_anim\_mvnx.mvnx\_import module}
\label{\detokenize{io_anim_mvnx:module-io_anim_mvnx.mvnx_import}}\label{\detokenize{io_anim_mvnx:io-anim-mvnx-mvnx-import-module}}\index{io\_anim\_mvnx.mvnx\_import (module)@\spxentry{io\_anim\_mvnx.mvnx\_import}\spxextra{module}}
This module contains the required functionality to import an MVNX file as a
moving set of bones into Blender.

It allows for different options regarding their connectivity, scale…
\index{global\_to\_inherited\_quats() (in module io\_anim\_mvnx.mvnx\_import)@\spxentry{global\_to\_inherited\_quats()}\spxextra{in module io\_anim\_mvnx.mvnx\_import}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx_import.global_to_inherited_quats}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.mvnx\_import.}}\sphinxbfcode{\sphinxupquote{global\_to\_inherited\_quats}}}{\emph{quaternions}, \emph{joints}, \emph{name\_to\_idx\_map}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{quaternions}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} {[}q1, q2, …{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{joints}} \textendash{} A list of segment connections in the form
{[}(parent\_name, child\_name), …{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name\_to\_idx\_map}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} A dict in the form \{seg\_name: idx, …\} where
The quaternion for the segment seg\_name can be found in quaternions{[}idx{]}.

\end{itemize}

\end{description}\end{quote}

Given the list of MVNX quaternions and their tree relations,
return a list with same shape, but each quaternion is expressed relative
to its parent. For that, it suffices the following calculation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{q\PYGZus{}child\PYGZus{}relative} \PYG{o}{=} \PYG{n}{q\PYGZus{}parent\PYGZus{}glob}\PYG{o}{.}\PYG{n}{conjugated}\PYG{p}{(}\PYG{p}{)} \PYG{o}{*} \PYG{n}{q\PYGZus{}child\PYGZus{}glob}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{warning}{Warning:}
This function assumes that the joints are given topologically sorted,
i.e. that all parents prior to the current connection have been already
visited when iterating the joint list from left to right (starting with
the roots, and going down the leafs in order).
\end{sphinxadmonition}

\end{fulllineitems}

\index{load\_mvnx\_into\_blender() (in module io\_anim\_mvnx.mvnx\_import)@\spxentry{load\_mvnx\_into\_blender()}\spxextra{in module io\_anim\_mvnx.mvnx\_import}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx_import.load_mvnx_into_blender}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.mvnx\_import.}}\sphinxbfcode{\sphinxupquote{load\_mvnx\_into\_blender}}}{\emph{context}, \emph{filepath}, \emph{mvnx\_schema\_path=None}, \emph{connectivity='CONNECTED'}, \emph{scale=1.0}, \emph{report=\textless{}built-in function print\textgreater{}}, \emph{frame\_start=0.0}, \emph{inherit\_rotations=True}, \emph{add\_identity\_pose=True}, \emph{add\_t\_pose=True}}{}
\end{fulllineitems}

\index{set\_bone\_head\_and\_tail() (in module io\_anim\_mvnx.mvnx\_import)@\spxentry{set\_bone\_head\_and\_tail()}\spxextra{in module io\_anim\_mvnx.mvnx\_import}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.mvnx_import.set_bone_head_and_tail}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.mvnx\_import.}}\sphinxbfcode{\sphinxupquote{set\_bone\_head\_and\_tail}}}{\emph{bone, segment\_points, joints, root\_points={[}'pHipOrigin'{]}, leaf\_points={[}'pTopOfHead', 'pRightTopOfHand', 'pLeftTopOfHand', 'pRightToe', 'pLeftToe'{]}, scale=1.0}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bone}} \textendash{} an EditBone

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{segment\_points}} \textendash{} A dict of dicts that allows to find an offset given
a joint connector. Expected: \{seg\_name: \{p\_name: 3d\_vector, …\}, …\}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{joints}} \textendash{} A list in the original MVNX ordering, in the form
{[}((seg\_ori, point\_ori), (seg\_dest, point\_dest)), …{]}, where each element
contains 4 strings summarizing the origin-\textgreater{}destiny of a connection.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{root\_points}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} If a given bone/segment is root (has no parent),
the first match in this list will be taken as bone.head.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{leaf\_points}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} If a given bone/segment is a leaf (has no
children), the first match in this list will be taken as bone.tail.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} A positive float by which head and tail vectors will
be multiplied.

\end{itemize}

\end{description}\end{quote}

For a given bone, this function reads the information of its parent and,
given some MVNX data and assumptions, calculates its head and tail
positions.

\begin{sphinxadmonition}{warning}{Warning:}\begin{description}
\item[{This function assumes the following:}] \leavevmode\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
If the bone has a parent, it can be found under bone.parent.

\item {} 
The head and tail of the parent have been already properly set.

\item {} 
If this bone is a root, its segment will have a point with
a label in root\_points.

\item {} 
If this bone is a leaf, its segment will have a point with
a label in leaf\_points.

\item {} 
For a given bone, there aren’t any possible collisions between the
different root or head\_points, i.e., the first match in the list
will always be a good match (this happens e.g. if each leaf has
a uniquely named leaf\_point, which is usually the case).

\end{enumerate}

\end{description}
\end{sphinxadmonition}

\end{fulllineitems}



\section{io\_anim\_mvnx.operators module}
\label{\detokenize{io_anim_mvnx:module-io_anim_mvnx.operators}}\label{\detokenize{io_anim_mvnx:io-anim-mvnx-operators-module}}\index{io\_anim\_mvnx.operators (module)@\spxentry{io\_anim\_mvnx.operators}\spxextra{module}}
This module contains subclasses from \sphinxcode{\sphinxupquote{bpy.types.Operator}} defining
user-callable functors. Operators can also be embedded in Panels and
other UI elements.
\index{ImportMVNX (class in io\_anim\_mvnx.operators)@\spxentry{ImportMVNX}\spxextra{class in io\_anim\_mvnx.operators}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.operators.}}\sphinxbfcode{\sphinxupquote{ImportMVNX}}}
Bases: \sphinxcode{\sphinxupquote{bpy\_types.Operator}}, \sphinxcode{\sphinxupquote{bpy\_extras.io\_utils.ImportHelper}}

Load an MVNX motion capture file. This Operator is heavily inspired in the
oficially supported ImportBVH.
\index{bl\_idname (io\_anim\_mvnx.operators.ImportMVNX attribute)@\spxentry{bl\_idname}\spxextra{io\_anim\_mvnx.operators.ImportMVNX attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.bl_idname}}\pysigline{\sphinxbfcode{\sphinxupquote{bl\_idname}}\sphinxbfcode{\sphinxupquote{ = 'import\_anim.mvnx'}}}
\end{fulllineitems}

\index{bl\_label (io\_anim\_mvnx.operators.ImportMVNX attribute)@\spxentry{bl\_label}\spxextra{io\_anim\_mvnx.operators.ImportMVNX attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.bl_label}}\pysigline{\sphinxbfcode{\sphinxupquote{bl\_label}}\sphinxbfcode{\sphinxupquote{ = 'Import MVNX'}}}
\end{fulllineitems}

\index{bl\_options (io\_anim\_mvnx.operators.ImportMVNX attribute)@\spxentry{bl\_options}\spxextra{io\_anim\_mvnx.operators.ImportMVNX attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.bl_options}}\pysigline{\sphinxbfcode{\sphinxupquote{bl\_options}}\sphinxbfcode{\sphinxupquote{ = \{'REGISTER', 'UNDO'\}}}}
\end{fulllineitems}

\index{bl\_rna (io\_anim\_mvnx.operators.ImportMVNX attribute)@\spxentry{bl\_rna}\spxextra{io\_anim\_mvnx.operators.ImportMVNX attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.bl_rna}}\pysigline{\sphinxbfcode{\sphinxupquote{bl\_rna}}\sphinxbfcode{\sphinxupquote{ = \textless{}bpy\_struct, Struct("IMPORT\_ANIM\_OT\_mvnx")\textgreater{}}}}
\end{fulllineitems}

\index{execute() (io\_anim\_mvnx.operators.ImportMVNX method)@\spxentry{execute()}\spxextra{io\_anim\_mvnx.operators.ImportMVNX method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.operators.ImportMVNX.execute}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{execute}}}{\emph{context}}{}
Passes the properties captured by the UI to the load\_mvnx\_into\_blender
function.
:returns: \sphinxcode{\sphinxupquote{\{"FINISHED"\}}} if everything went OK.

\end{fulllineitems}


\end{fulllineitems}



\section{io\_anim\_mvnx.utils module}
\label{\detokenize{io_anim_mvnx:module-io_anim_mvnx.utils}}\label{\detokenize{io_anim_mvnx:io-anim-mvnx-utils-module}}\index{io\_anim\_mvnx.utils (module)@\spxentry{io\_anim\_mvnx.utils}\spxextra{module}}
Utilities for interaction with Blender
\index{ArgumentParserForBlender (class in io\_anim\_mvnx.utils)@\spxentry{ArgumentParserForBlender}\spxextra{class in io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.ArgumentParserForBlender}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{ArgumentParserForBlender}}}{\emph{prog=None}, \emph{usage=None}, \emph{description=None}, \emph{epilog=None}, \emph{parents={[}{]}}, \emph{formatter\_class=\textless{}class 'argparse.HelpFormatter'\textgreater{}}, \emph{prefix\_chars='-'}, \emph{fromfile\_prefix\_chars=None}, \emph{argument\_default=None}, \emph{conflict\_handler='error'}, \emph{add\_help=True}, \emph{allow\_abbrev=True}}{}
Bases: \sphinxcode{\sphinxupquote{argparse.ArgumentParser}}

This class is identical to its superclass, except for the parse\_args
method (see docstring). It resolves the ambiguity generated when calling
Blender from the CLI with a python script, and both Blender and the script
have arguments. E.g., the following call will make Blender crash because
it will try to process the script’s -a and -b flags:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{blender} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{python} \PYG{n}{my\PYGZus{}script}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

To bypass this issue this class uses the fact that Blender will ignore all
arguments given after a double-dash (‘\textendash{}’). The approach is that all
arguments before ‘\textendash{}’ go to Blender, arguments after go to the script.
The following CLI calls work fine:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{blender} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{python} \PYG{n}{my\PYGZus{}script}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{b} \PYG{l+m+mi}{2}
\PYG{n}{blender} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{python} \PYG{n}{my\PYGZus{}script}\PYG{o}{.}\PYG{n}{py} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\end{sphinxVerbatim}
\index{get\_argv\_after\_doubledash() (io\_anim\_mvnx.utils.ArgumentParserForBlender method)@\spxentry{get\_argv\_after\_doubledash()}\spxextra{io\_anim\_mvnx.utils.ArgumentParserForBlender method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.ArgumentParserForBlender.get_argv_after_doubledash}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_argv\_after\_doubledash}}}{\emph{argv}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{argv}} (\sphinxstyleliteralemphasis{\sphinxupquote{list\textless{}str\textgreater{}}}) \textendash{} Expected to be sys.argv (or alike).

\item[{Returns}] \leavevmode
The argv sublist after the first \sphinxcode{\sphinxupquote{'-{-}'}} element (if
present, otherwise returns an empty list).

\item[{Return type}] \leavevmode
list of str

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
Works with any \sphinxstyleemphasis{ordered} collection of strings (e.g. list, tuple).
\end{sphinxadmonition}

\end{fulllineitems}

\index{parse\_args() (io\_anim\_mvnx.utils.ArgumentParserForBlender method)@\spxentry{parse\_args()}\spxextra{io\_anim\_mvnx.utils.ArgumentParserForBlender method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.ArgumentParserForBlender.parse_args}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parse\_args}}}{}{}
This method is expected to behave identically as in the superclass,
except that the sys.argv list will be pre-processed using
get\_argv\_after\_doubledash before. See the docstring of the class for
usage examples and details.

\begin{sphinxadmonition}{note}{Note:}
By default, \sphinxtitleref{argparse.ArgumentParser} will call \sphinxtitleref{sys.exit()} when
encountering an error. Blender will react to that shutting down,
making it look like a crash. Make sure the arguments are correct!
\end{sphinxadmonition}

\end{fulllineitems}


\end{fulllineitems}

\index{ImportFilesCollection (class in io\_anim\_mvnx.utils)@\spxentry{ImportFilesCollection}\spxextra{class in io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.ImportFilesCollection}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{ImportFilesCollection}}}
Bases: \sphinxcode{\sphinxupquote{bpy\_types.PropertyGroup}}

This property group allows to load multiple files from the UI file browser
menu, by selecting them with shift pressed.
Source and usage example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
https://www.blender.org/forum/viewtopic.php?t=26470
\end{sphinxVerbatim}
\index{bl\_rna (io\_anim\_mvnx.utils.ImportFilesCollection attribute)@\spxentry{bl\_rna}\spxextra{io\_anim\_mvnx.utils.ImportFilesCollection attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.ImportFilesCollection.bl_rna}}\pysigline{\sphinxbfcode{\sphinxupquote{bl\_rna}}\sphinxbfcode{\sphinxupquote{ = \textless{}bpy\_struct, Struct("ImportFilesCollection")\textgreater{}}}}
\end{fulllineitems}


\end{fulllineitems}

\index{KeymapManager (class in io\_anim\_mvnx.utils)@\spxentry{KeymapManager}\spxextra{class in io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{KeymapManager}}}
Bases: \sphinxcode{\sphinxupquote{list}}

This class implements functionality for registering/deregistering keymaps
into Blender. It also behaves like a regular list, holding the keymaps
currently registered. To inspect the registered keymaps simply iterate
the instance.
\index{KEYMAP\_NAME (io\_anim\_mvnx.utils.KeymapManager attribute)@\spxentry{KEYMAP\_NAME}\spxextra{io\_anim\_mvnx.utils.KeymapManager attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager.KEYMAP_NAME}}\pysigline{\sphinxbfcode{\sphinxupquote{KEYMAP\_NAME}}\sphinxbfcode{\sphinxupquote{ = 'Object Mode'}}}
\end{fulllineitems}

\index{KEYMAP\_REGION\_TYPE (io\_anim\_mvnx.utils.KeymapManager attribute)@\spxentry{KEYMAP\_REGION\_TYPE}\spxextra{io\_anim\_mvnx.utils.KeymapManager attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager.KEYMAP_REGION_TYPE}}\pysigline{\sphinxbfcode{\sphinxupquote{KEYMAP\_REGION\_TYPE}}\sphinxbfcode{\sphinxupquote{ = 'WINDOW'}}}
\end{fulllineitems}

\index{KEYMAP\_SPACE\_TYPE (io\_anim\_mvnx.utils.KeymapManager attribute)@\spxentry{KEYMAP\_SPACE\_TYPE}\spxextra{io\_anim\_mvnx.utils.KeymapManager attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager.KEYMAP_SPACE_TYPE}}\pysigline{\sphinxbfcode{\sphinxupquote{KEYMAP\_SPACE\_TYPE}}\sphinxbfcode{\sphinxupquote{ = 'EMPTY'}}}
\end{fulllineitems}

\index{register() (io\_anim\_mvnx.utils.KeymapManager method)@\spxentry{register()}\spxextra{io\_anim\_mvnx.utils.KeymapManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager.register}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{register}}}{\emph{context}, \emph{key}, \emph{stroke\_mode}, \emph{op\_name}, \emph{ctrl=True}, \emph{shift=True}, \emph{alt=False}}{}
Adds a new keymap to this collection, and to the config in
\sphinxcode{\sphinxupquote{context.window\_manager.keyconfigs.addon}}. See the API for details:

\begin{DUlineblock}{0em}
\item[] \sphinxurl{https://docs.blender.org/api/blender2.8/bpy.types.KeyMap.html}
\item[] \sphinxurl{https://docs.blender.org/api/blender2.8/bpy.types.KeyMapItem.html}
\item[] \sphinxurl{https://docs.blender.org/manual/de/dev/advanced/keymap\_editing.html}
\end{DUlineblock}

Usage example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{kmm} \PYG{o}{=} \PYG{n}{KeymapManager}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{kmm}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{n}{bpy}\PYG{o}{.}\PYG{n}{context}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{D}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PRESS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{MyOperator}\PYG{o}{.}\PYG{n}{bl\PYGZus{}idname}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{context}} (\sphinxstyleliteralemphasis{\sphinxupquote{bpy.types.Context}}) \textendash{} The Blender context to work in.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{key}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} See bpy.types.KeyMapItem.key\_modifier

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stroke\_mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} See bpy.types.KeyMapItem.value

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{op\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of a valid operation in \sphinxcode{\sphinxupquote{bpy.ops}}
(usually the \sphinxcode{\sphinxupquote{bl\_idname}})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ctrl}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{shift}}\sphinxstyleliteralstrong{\sphinxupquote{, }}\sphinxstyleliteralstrong{\sphinxupquote{alt}} (\sphinxstyleliteralemphasis{\sphinxupquote{booleans}}) \textendash{} Modifiers of the \sphinxcode{\sphinxupquote{key}}

\end{itemize}

\item[{Returns}] \leavevmode
None

\end{description}\end{quote}

\end{fulllineitems}

\index{unregister() (io\_anim\_mvnx.utils.KeymapManager method)@\spxentry{unregister()}\spxextra{io\_anim\_mvnx.utils.KeymapManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.KeymapManager.unregister}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{unregister}}}{}{}
Removes every mapped item from every keymap in this collection, and
then empties the collection.

\end{fulllineitems}


\end{fulllineitems}

\index{OperatorToMenuManager (class in io\_anim\_mvnx.utils)@\spxentry{OperatorToMenuManager}\spxextra{class in io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.OperatorToMenuManager}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{OperatorToMenuManager}}}
Bases: \sphinxcode{\sphinxupquote{list}}

This class implements functionality for adding/removing operators
into Blender UI menus. It also behaves like a regular list, holding
the currently registered items. Usage example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{omm} \PYG{o}{=} \PYG{n}{OperatorToMenuManager}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} In register():}
\PYG{n}{omm}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{n}{MyOperator}\PYG{p}{,} \PYG{n}{bpy}\PYG{o}{.}\PYG{n}{types}\PYG{o}{.}\PYG{n}{VIEW3D\PYGZus{}MT\PYGZus{}object}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} ... in unregister():}
\PYG{n}{omm}\PYG{o}{.}\PYG{n}{unregister}
\end{sphinxVerbatim}
\index{register() (io\_anim\_mvnx.utils.OperatorToMenuManager method)@\spxentry{register()}\spxextra{io\_anim\_mvnx.utils.OperatorToMenuManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.OperatorToMenuManager.register}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{register}}}{\emph{op\_class}, \emph{menu\_class}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{op\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{bpy.types.Operator}}) \textendash{} (Sub)class handle with desired
functionality.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{menu\_class}} (\sphinxstyleliteralemphasis{\sphinxupquote{bpy.types.\{Header}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{Panel}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{..\}}}) \textendash{} Class handle for the Blender GUI where the
functionality can be triggered.

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxcode{\sphinxupquote{op\_class}} must define the \sphinxcode{\sphinxupquote{bl\_idname}} and \sphinxcode{\sphinxupquote{bl\_label}} fields.
\end{sphinxadmonition}

\end{fulllineitems}

\index{unregister() (io\_anim\_mvnx.utils.OperatorToMenuManager method)@\spxentry{unregister()}\spxextra{io\_anim\_mvnx.utils.OperatorToMenuManager method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.OperatorToMenuManager.unregister}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{unregister}}}{}{}
Removes every mapped operator from every menu class in this collection,
then empties the collection.

\end{fulllineitems}


\end{fulllineitems}

\index{is\_number() (in module io\_anim\_mvnx.utils)@\spxentry{is\_number()}\spxextra{in module io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.is_number}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{is\_number}}}{\emph{s}}{}~\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
True iff s is a number.

\end{description}\end{quote}

\end{fulllineitems}

\index{make\_timestamp() (in module io\_anim\_mvnx.utils)@\spxentry{make\_timestamp()}\spxextra{in module io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.make_timestamp}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{make\_timestamp}}}{\emph{timezone='Europe/Berlin'}}{}
Output example: day, month, year, hour, min, sec, milisecs:
10\_Feb\_2018\_20:10:16.151

\end{fulllineitems}

\index{resolve\_path() (in module io\_anim\_mvnx.utils)@\spxentry{resolve\_path()}\spxextra{in module io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.resolve_path}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{resolve\_path}}}{\emph{*path\_elements}}{}
A convenience path wrapper to find elements in this package. Retrieves
the absolute path, given the OS-agnostic path relative to the package
root path (by bysically joining the path elements via \sphinxcode{\sphinxupquote{os.path.join}}).
E.g., the following call retrieves the absolute path for
\sphinxcode{\sphinxupquote{\textless{}PACKAGE\_ROOT\textgreater{}/a/b/test.txt}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{resolve\PYGZus{}path}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Params strings path\_elements}] \leavevmode
From left to right, the path nodes,
the last one being the filename.

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{rot\_euler\_degrees() (in module io\_anim\_mvnx.utils)@\spxentry{rot\_euler\_degrees()}\spxextra{in module io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.rot_euler_degrees}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{rot\_euler\_degrees}}}{\emph{rot\_x}, \emph{rot\_y}, \emph{rot\_z}, \emph{order='XYZ'}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{rot}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Rotation angle in degrees.

\item[{Returns}] \leavevmode
An Euler rotation object with the given rotations (converted to
gradians) and rotation order.

\end{description}\end{quote}

\end{fulllineitems}

\index{str\_to\_vec() (in module io\_anim\_mvnx.utils)@\spxentry{str\_to\_vec()}\spxextra{in module io\_anim\_mvnx.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.utils.str_to_vec}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.utils.}}\sphinxbfcode{\sphinxupquote{str\_to\_vec}}}{\emph{s}}{}
Converts a string like ‘1.23, 2.34 …’ into a list
like {[}1.23, 2.34, …{]}

\end{fulllineitems}



\section{Module contents}
\label{\detokenize{io_anim_mvnx:module-io_anim_mvnx}}\label{\detokenize{io_anim_mvnx:module-contents}}\index{io\_anim\_mvnx (module)@\spxentry{io\_anim\_mvnx}\spxextra{module}}
This add-on allows you to import motion capture data in MVNX format
into Blender.

After activating it, it features an operator that can be found in
\sphinxcode{\sphinxupquote{{[}File \textgreater{} Import/Export{]}}}. Clicking on it will open a file navigator
with a set of options to customize how the MVNX will be imported
into a Blender armature.

Position the mouse over the different options or read the corresponding
docstrings to get more info about what do they do.

To install this add-on, make sure Blender’s Python is able to find it
under \sphinxcode{\sphinxupquote{addon\_utils.paths()}}, and that the Blender version matches to make
it installable. Alternatively, run this init file as a script from Blender.
\index{register() (in module io\_anim\_mvnx)@\spxentry{register()}\spxextra{in module io\_anim\_mvnx}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.register}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.}}\sphinxbfcode{\sphinxupquote{register}}}{}{}
Main register function, called on startup by Blender

\end{fulllineitems}

\index{unregister() (in module io\_anim\_mvnx)@\spxentry{unregister()}\spxextra{in module io\_anim\_mvnx}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{io_anim_mvnx:io_anim_mvnx.unregister}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{io\_anim\_mvnx.}}\sphinxbfcode{\sphinxupquote{unregister}}}{}{}
Main unregister function, called on shutdown by Blender

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{i}
\item\relax\sphinxstyleindexentry{io\_anim\_mvnx}\sphinxstyleindexpageref{io_anim_mvnx:\detokenize{module-io_anim_mvnx}}
\item\relax\sphinxstyleindexentry{io\_anim\_mvnx.mvnx}\sphinxstyleindexpageref{io_anim_mvnx:\detokenize{module-io_anim_mvnx.mvnx}}
\item\relax\sphinxstyleindexentry{io\_anim\_mvnx.mvnx\_import}\sphinxstyleindexpageref{io_anim_mvnx:\detokenize{module-io_anim_mvnx.mvnx_import}}
\item\relax\sphinxstyleindexentry{io\_anim\_mvnx.operators}\sphinxstyleindexpageref{io_anim_mvnx:\detokenize{module-io_anim_mvnx.operators}}
\item\relax\sphinxstyleindexentry{io\_anim\_mvnx.utils}\sphinxstyleindexpageref{io_anim_mvnx:\detokenize{module-io_anim_mvnx.utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}